### Mini-DEX — Technical Overview (for Junior Blockchain Developers)

This document explains the Mini-DEX codebase at a gentle pace. You’ll learn how the Solana program is structured with Anchor, what each file does, and how instructions, accounts, PDAs, and SPL Token CPIs come together.

#### Repository layout (relevant parts)
- `mini-dex/Anchor.toml` — Anchor workspace config: program IDs per cluster, default provider, and scripts.
- `mini-dex/programs/mini-dex/` — On-chain program (Rust + Anchor).
  - `src/lib.rs` — Program entrypoints (instructions) and account validation structs.
  - `src/state.rs` — On-chain account data structures (e.g., `Pool`).
  - `src/utils.rs` — Math helpers for swaps and LP token calculations.
  - `src/errors.rs` — Custom error codes for readable failures.
  - `Cargo.toml` — Rust crate metadata and dependencies for the program.
- `mini-dex/tests/mini-dex.ts` — TypeScript integration tests using Anchor’s client.
- `mini-dex/target/` — Build artifacts generated by Anchor (IDL, `.so` binaries, keypairs, etc.).

---

### Anchor basics (quick recap)
- A Solana program compiled with Anchor exposes functions (instructions) on-chain under `#[program]` in `lib.rs`.
- Each instruction takes a `Context<...>` whose generic parameter is a struct describing all required accounts and their constraints.
- Anchor auto-validates PDAs, addresses, mutability, signers, and ownership based on those constraints.
- CPI (Cross‑Program Invocation) calls into other programs; here we use `anchor_spl::token` to transfer/mint/burn SPL tokens.

---

### Core program: `src/lib.rs`
Key elements:
- `declare_id!("<PROGRAM_ID>");` — Program’s public key (updated via `anchor keys sync`).
- `#[program] pub mod mini_dex { ... }` — Instruction handlers:
  - `initialize_pool(ctx)`
  - `add_liquidity(ctx, amount_a, amount_b, min_lp_tokens)`
  - `swap(ctx, amount_in, min_amount_out, is_a_to_b)`
  - `remove_liquidity(ctx, lp_token_amount, min_amount_a, min_amount_b)`
- `#[derive(Accounts)]` structs — Account validation for each instruction, using PDAs and constraints.

Instruction details:
1) `initialize_pool`
   - Purpose: Creates and initializes a new `Pool` account and its PDAs/vaults.
   - Accounts (simplified):
     - `pool` (PDA): `seeds = ["pool", token_a_mint, token_b_mint]`
     - `pool_authority` (PDA): `seeds = ["pool_authority", pool]` — authority for vaults and LP mint
     - `token_a_vault`, `token_b_vault` (PDAs): Token accounts owned by `pool_authority`
     - `lp_token_mint` (PDA): SPL Mint for LP tokens
   - Initializes `Pool` fields: mints, vaults, reserve counters, default fee (30 bps), and the `authority_bump` used to sign CPIs.

2) `add_liquidity(amount_a, amount_b, min_lp_tokens)`
   - Transfers user’s Token A/B to vaults.
   - Mints LP tokens proportionally using `utils::calculate_lp_tokens`.
   - Updates `reserve_a` and `reserve_b` in `Pool`.
   - Constraints prevent spoofing:
     - Vault and LP mint addresses must match those recorded in `pool`.
     - User token accounts must have the correct mint.

3) `swap(amount_in, min_amount_out, is_a_to_b)`
   - Uses constant‑product math to compute `amount_out` via `utils::calculate_swap_amount`.
   - Applies a configurable fee in basis points (`pool.fee_numerator`, default 30 bps).
   - Executes two token transfers:
     - User → vault (input token)
     - Vault → user (output token), signed by PDA `pool_authority` using `seeds = ["pool_authority", pool, bump]`.
   - Updates reserves accordingly.

4) `remove_liquidity(lp_token_amount, min_amount_a, min_amount_b)`
   - Burns the user’s LP tokens.
   - Returns proportional amounts of A and B from vaults to the user.
   - Updates reserves.

Logging: Instruction functions use `msg!(...)` for runtime logs.

---

### On-chain state: `src/state.rs`
`Pool` account holds:
- `authority: Pubkey` — the `pool_authority` PDA
- `token_a_mint`, `token_b_mint`: SPL mints for the pool
- `token_a_vault`, `token_b_vault`: vault token accounts
- `lp_token_mint`: mint for LP tokens
- `reserve_a`, `reserve_b`: current reserves
- `fee_numerator` (bps): swap fee (e.g., 30 = 0.3%)
- `authority_bump`: PDA bump used for signing CPIs

Also defines `LEN` to compute account space for `pool` creation.

---

### Math helpers: `src/utils.rs`
- `calculate_swap_amount(amount_in, reserve_in, reserve_out, fee_bps)`
  - Implements x*y=k with fee in basis points (`10_000 - fee_bps` multiplier).
  - Checks for non‑zero reserves and overflow.
- `calculate_lp_tokens(amount_a, amount_b, reserve_a, reserve_b, lp_supply)`
  - First deposit: approximates `sqrt(a*b)` (uses `f64` briefly; fine for demos).
  - Subsequent deposits: mints `min(amount_a * lp_supply / reserve_a, amount_b * lp_supply / reserve_b)`.

Production note: replace the floating‑point sqrt with an integer sqrt for deterministic rounding.

---

### Errors: `src/errors.rs`
Defines `DexError` with readable messages:
- `SlippageExceeded`
- `InvalidCalculation`
- `InsufficientLiquidity`
- `MathOverflow`
- `InvalidTokenMints`

These bubble up as program errors Anchor clients can decode.

---

### Account validation and security
- PDAs tie critical authorities to deterministic seeds.
- `address = pool.<field>` binds incoming accounts to what the pool recorded at initialization.
- `constraint = user_token_*.mint == pool.*_mint` ensures user accounts are for the correct tokens.
- Token operations use `anchor_spl::token` CPIs: `Transfer`, `MintTo`, `Burn`.

Attack surface (typical for AMMs):
- Spoofed accounts (mitigated by constraints above).
- Arithmetic edge cases (mitigated by overflow checks and `require!`).
- Price manipulation/oracles (not present; this is an isolated demo AMM).

---

### Tests: `tests/mini-dex.ts`
- Uses `@coral-xyz/anchor` to connect to localnet (`AnchorProvider.env()`).
- Builds mints and associated token accounts with `@solana/spl-token` helpers.
- Derives PDAs client‑side with `PublicKey.findProgramAddressSync` to match on-chain seeds.
- Runs the full flow:
  1. Airdrop SOL to a fresh `user`
  2. Create token A/B mints and mint tokens to the user
  3. Derive PDAs and call `initialize_pool`
  4. `add_liquidity`
  5. `swap` A→B and B→A
  6. `remove_liquidity`

The passing tests confirm end‑to‑end behavior and correctness of accounts/PDAs.

---

### Glossary (quick)
- PDA (Program Derived Address): Non‑signer account derived from seeds+bump that can sign via program logic.
- LP Token: Represents a share of pool liquidity and fee accrual; minted on deposit, burned on withdrawal.
- Basis Points (bps): 1 bps = 0.01%. 30 bps = 0.3%.
- CPI: Cross‑Program Invocation. Calling another program (e.g., SPL Token) from your program.

---

### Where to extend from here
- Governance to update fees safely
- Concentrated liquidity positions
- Routing between multiple pools
- Per‑pool parameters (tick spacing, fee tiers)

Happy building!